<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Voice Karting</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /*
        3D Karting Game with Voice Control
        Technologies:
        - Three.js for 3D rendering
        - Web Speech API for voice commands

        Instructions:
        - Include Three.js via CDN
        - Run on a server (e.g., Live Server) to enable SpeechRecognition
        */
        
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
        hemi.position.set(0, 200, 0);
        scene.add(hemi);

        // Track (simple plane)
        const trackGeo = new THREE.PlaneGeometry(200, 200, 10, 10);
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const track = new THREE.Mesh(trackGeo, trackMat);
        track.rotation.x = -Math.PI / 2;
        scene.add(track);

        // Kart (box as placeholder)
        const kartGeo = new THREE.BoxGeometry(2, 1, 4);
        const kartMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const kart = new THREE.Mesh(kartGeo, kartMat);
        kart.position.set(0, 0.5, 0);
        scene.add(kart);

        // Camera follows kart
        camera.position.set(0, 5, -10);
        camera.lookAt(kart.position);

        // Controls state
        const controls = { forward: false, backward: false, left: false, right: false };
        let speed = 0;

        // Voice Control Setup
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
        alert('Your browser does not support Speech Recognition.');
        }
        const recognizer = new SpeechRecognition();
        recognizer.continuous = true;
        recognizer.lang = 'en-US';
        recognizer.interimResults = false;
        recognizer.maxAlternatives = 1;
        recognizer.start();

        recognizer.onresult = (event) => {
        const transcript = event.results[event.results.length-1][0].transcript.trim().toLowerCase();
        console.log('Voice command:', transcript);

        // Map commands
        if (transcript.includes('forward') || transcript.includes('accelerate')) {
            controls.forward = true;
        } else if (transcript.includes('back') || transcript.includes('reverse') || transcript.includes('brake')) {
            controls.backward = true;
        } else if (transcript.includes('left')) {
            controls.left = true;
        } else if (transcript.includes('right')) {
            controls.right = true;
        }
        // Stop on "stop"
        if (transcript.includes('stop')) {
            controls.forward = controls.backward = controls.left = controls.right = false;
            speed = 0;
        }
        };

        recognizer.onerror = (e) => { console.error(e); };

        // Resize
        window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation Loop
        function animate() {
        requestAnimationFrame(animate);

        // Update speed
        if (controls.forward) speed = Math.min(speed + 0.1, 2);
        if (controls.backward) speed = Math.max(speed - 0.1, -1);
        if (!controls.forward && !controls.backward) speed *= 0.98;

        // Update rotation
        if (controls.left) kart.rotation.y += 0.03;
        if (controls.right) kart.rotation.y -= 0.03;

        // Move kart
        kart.position.x += Math.sin(kart.rotation.y) * speed;
        kart.position.z += Math.cos(kart.rotation.y) * speed;

        // Update camera
        const relativeCameraOffset = new THREE.Vector3(0, 5, -10);
        const cameraOffset = relativeCameraOffset.applyMatrix4(kart.matrixWorld);
        camera.position.lerp(cameraOffset, 0.1);
        camera.lookAt(kart.position);

        renderer.render(scene, camera);
        }
        animate();

    </script>
  </body>
</html>